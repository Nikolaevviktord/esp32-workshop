# Сенсорная кнопка

Цель: Освоить использование встроенных ёмкостных датчиков ESP32.

## Теория:

<blockquote>

### Как работает touch-пин?

<details> 
  <summary> Объяснение </summary>

  Представьте, что touch-пин — это маленькая **"электронная лужа"**, а ваше прикосновение — это **"вливание" дополнительной воды**.

  Вот как это работает шаг за шагом:
  
  1.  **"Пустая лужа" (Базовая ёмкость):**
      *   Сам металлический контакт пина на плате ESP32 и дорожки, ведущие к нему, уже образуют крошечный **"конденсатор"** по отношению к "земле" (GND) и другим элементам платы.
      *   У этого конденсатора есть небольшая, но измеримая **базовая электрическая ёмкость** (обозначим ее `C_base`). Представьте это как небольшой объем воды в луже *до* вашего прикосновения.
  
  2.  **"Палец приближается" (Добавление ёмкости):**
      *   Человеческое тело (особенно палец) является хорошим проводником электричества.
      *   Когда вы подносите палец или касаетесь проводящего предмета, соединенного с пином (даже через изолятор!), вы создаете **второй, дополнительный "конденсатор"**. Одна "обкладка" этого конденсатора — это сам touch-пин, а вторая — ваш палец (который, по сути, соединен с "землей" через ваше тело и окружающую среду).
      *   Эта новая ёмкость (`C_touch`) **параллельно** добавляется к базовой (`C_base`). Общая ёмкость пина теперь становится `C_total = C_base + C_touch`.
      *   **Аналогия:** Ваш палец — это как будто вы поднесли к луже еще одно ведерко с водой и вылили его содержимое в лужу. Объем воды (общая ёмкость) увеличился.
  
  3.  **"Измерение объема" (Принцип измерения - RC-цепь):**
      *   Внутри ESP32 touch-пин подключен к специальной схеме через встроенный **резистор** (`R`).
      *   Микроконтроллер периодически (очень быстро!) выполняет одну и ту же операцию:
          1.  **Зарядка:** Он подключает внутренний источник напряжения через резистор `R` к touch-пину (который теперь имеет общую ёмкость `C_total`). Это как открыть кран, чтобы наполнить нашу лужу через узкую трубку (резистор).
          2.  **Ожидание:** ESP32 ждет, пока напряжение на пине достигнет определенного порогового уровня (например, 63% от напряжения питания).
      *   **Ключевой момент:** Скорость зарядки напрямую зависит от **общей емкости** `C_total` и значения резистора `R` (это называется **RC-цепь**). Чем *больше* емкость `C_total`, тем *дольше* требуется времени, чтобы напряжение на пине достигло порогового значения.
      *   **Аналогия:** Представьте, что вы наполняете ведро водой через шланг. Чем *больше* ведро (емкость), тем *дольше* вам нужно держать кран открытым, чтобы оно наполнилось до определенной отметки (порогового напряжения).
  
  4.  **"Секундомер" (Преобразование в цифровое значение):**
      *   ESP32 имеет встроенный **высокоточный таймер**, который измеряет **время**, необходимое для зарядки пина от 0V до порогового напряжения.
      *   Это измеренное время (`T_charge`) **прямо пропорционально** общей ёмкости `C_total`.
      *   Чем **дольше** время зарядки (`T_charge`), тем **больше** общая ёмкость (`C_total`).
      *   Значение этого времени (`T_charge`) преобразуется микроконтроллером в удобное для программы **цифровое число** (обычно типа `uint16_t`).
  
  5.  **"Обнаружение прикосновения" (Интерпретация):**
      *   **Без прикосновения:** Общая ёмкость `C_total` = `C_base` (небольшая). Время зарядки `T_charge` относительно **мало**. Соответствующее цифровое значение будет **высоким** (например, 80-100).
      *   **При прикосновении:** Общая ёмкость `C_total` = `C_base` + `C_touch` (значительно больше). Время зарядки `T_charge` становится **значительно больше**. Цифровое значение резко **уменьшается** (например, падает до 20-40).
      *   **Детектирование:** Программа на ESP32 просто сравнивает текущее прочитанное значение с пороговым числом. Если значение **стало меньше порога** — значит, произошло прикосновение (ёмкость увеличилась).
  
  **Важные нюансы:**
  
  *   **Чувствительность:** Зависит от площади контакта, расстояния до пальца (можно детектировать даже приближение через тонкий пластик/стекло!), настройки порога.
  *   **Помехи:** Длинные провода к сенсору, влажность, электромагнитные наводки, температура — всё это может изменять базовую ёмкость (`C_base`) или создавать ложные изменения, похожие на прикосновение. Требуется аккуратное проектирование и калибровка.
  *   **"Паразитная ёмкость":** `C_base` — это и есть та самая паразитная емкость, существующая всегда. Сенсор детектирует *изменение* этой емкости, вызванное прикосновением (`C_touch`).
  
  **Итог:**
  
  Touch-пин ESP32 работает как **крошечный "часовой" для электричества**. Микроконтроллер постоянно замеряет, **как долго** нужно "кормить" этот пин током, чтобы он "наелся" до определенного уровня. **Прикосновение пальца** делает пину "труднее наесться" (увеличивает его "электроёмкость"), из-за чего процесс "кормления" занимает **больше времени**. ESP32 замечает это увеличение времени и говорит: "Ага, прикоснулись!".

</details>

---

</blockquote>

> ### Считать значение ёмкостного датчика
> ```cpp
> touchRead(uint8_t pin) -> uint16_t
> ```
> - меньше значение - сильнее касание

---

### Типичные значения:

- Без касания: 50-100
- При касании: 10-30

---

### Калибровка порога

- Экспериментальное определение порогового значения для конкретного сенсора

## Итоговый код:

```cpp
const auto pin_led = 26, pin_touch = 14;
const auto threshold = 30;  // Порог срабатывания
  
void setup() {
    pinMode(pin_led, OUTPUT);
}

void loop() {
    // Чтение значения ёмкостного датчика
    auto value = touchRead(pin_touch);
    bool touched = value < threshold;
    
    digitalWrite(pin_led, touched);  // Управление светодиодом
    delay(100);
}
```
